name: Tag and Release

on:
  push:
    branches:
      - main

jobs:
  tag-and-release:
    name: Tag and Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: üìä Determine version bump
        id: bump
        run: |
          echo "::group::Determining version bump type"
          # Get the latest commit message
          COMMIT_MSG=$(git log -1 --pretty=%B)
          
          # Determine bump type based on commit message
          if [[ "$COMMIT_MSG" == *"BREAKING CHANGE:"* ]] || [[ "$COMMIT_MSG" == *"MAJOR:"* ]]; then
            echo "BUMP_TYPE=major" >> $GITHUB_OUTPUT
          elif [[ "$COMMIT_MSG" == *"FEAT:"* ]] || [[ "$COMMIT_MSG" == *"FEATURE:"* ]] || [[ "$COMMIT_MSG" == *"MINOR:"* ]]; then
            echo "BUMP_TYPE=minor" >> $GITHUB_OUTPUT
          else
            echo "BUMP_TYPE=patch" >> $GITHUB_OUTPUT
          fi
          
          echo "Determined bump type: $(cat $GITHUB_OUTPUT | grep BUMP_TYPE | cut -d= -f2)"
          echo "::endgroup::"
      
      - name: üè∑Ô∏è Get latest tag
        id: latest_tag
        run: |
          echo "::group::Finding latest tag"
          # Get the latest tag or set to v0.1.0 if none exists
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.1.0")
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"
          echo "::endgroup::"
      
      - name: üßÆ Calculate new version
        id: version
        run: |
          echo "::group::Calculating new version"
          LATEST_TAG="${{ steps.latest_tag.outputs.LATEST_TAG }}"
          BUMP_TYPE="${{ steps.bump.outputs.BUMP_TYPE }}"
          
          # Remove 'v' prefix for version calculation
          VERSION=${LATEST_TAG#v}
          
          # Extract version components, keeping original values
          # Use regex to extract numbers from each component
          if [[ "$VERSION" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"
          else
            # Try to extract whatever numbers we can
            MAJOR=$(echo "$VERSION" | sed -E 's/^([0-9]+).*/\1/g')
            MINOR=$(echo "$VERSION" | sed -E 's/^[^.]*\.([0-9]+).*/\1/g')
            PATCH=$(echo "$VERSION" | sed -E 's/^[^.]*\.[^.]*\.([0-9]+).*/\1/g')
            
            # Set defaults for any component that couldn't be extracted
            [[ -z "$MAJOR" || ! "$MAJOR" =~ ^[0-9]+$ ]] && MAJOR=0
            [[ -z "$MINOR" || ! "$MINOR" =~ ^[0-9]+$ ]] && MINOR=0
            [[ -z "$PATCH" || ! "$PATCH" =~ ^[0-9]+$ ]] && PATCH=0
            
            echo "Warning: Non-standard version format in tag '$LATEST_TAG', extracted components: $MAJOR.$MINOR.$PATCH"
          fi
          
          # Increment version based on bump type
          if [ "$BUMP_TYPE" == "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$BUMP_TYPE" == "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi
          
          # Create new version string
          NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"
          echo "::endgroup::"
      
      - name: üìå Create and push tag
        run: |
          echo "::group::Creating and pushing tag"
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"
          BUMP_TYPE="${{ steps.bump.outputs.BUMP_TYPE }}"
          
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Create and push the new tag
          git tag -a $NEW_VERSION -m "Release $NEW_VERSION ($BUMP_TYPE bump)"
          git push https://${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git $NEW_VERSION
          
          echo "Created and pushed tag: $NEW_VERSION"
          echo "::endgroup::"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üìù Create GitHub Release
        run: |
          echo "::group::Creating GitHub Release"
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"
          BUMP_TYPE="${{ steps.bump.outputs.BUMP_TYPE }}"
          
          # Get all commits since the last tag
          LATEST_TAG="${{ steps.latest_tag.outputs.LATEST_TAG }}"
          
          # Get commit history in a cleaner format
          COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s")
          
          # Process commits into a clean list
          CHANGES=""
          while IFS= read -r line; do
            # Skip merge commits
            if [[ "$line" == "Merge "* ]]; then
              continue
            fi
            
            # Standardize commit prefixes to lowercase
            if [[ "${line,,}" =~ ^(breaking change:|major:|feat:|feature:|minor:|fix:|patch:|chore:|docs:|style:|refactor:|perf:|test:|build:|ci:) ]]; then
              # Extract prefix and message
              PREFIX=$(echo "$line" | grep -io "^[a-zA-Z ]*:" | tr '[:upper:]' '[:lower:]')
              MESSAGE=$(echo "$line" | sed -E "s/^[a-zA-Z ]*://i" | sed -e 's/^[[:space:]]*//')
              
              # Standardize prefixes
              if [[ "${PREFIX,,}" == "breaking change:" ]] || [[ "${PREFIX,,}" == "major:" ]]; then
                PREFIX="breaking change:"
              elif [[ "${PREFIX,,}" == "feat:" ]] || [[ "${PREFIX,,}" == "feature:" ]] || [[ "${PREFIX,,}" == "minor:" ]]; then
                PREFIX="feat:"
              elif [[ "${PREFIX,,}" == "fix:" ]] || [[ "${PREFIX,,}" == "patch:" ]]; then
                PREFIX="fix:"
              fi
              
              CHANGES="${CHANGES}- ${PREFIX} ${MESSAGE}"
            else
              # For commits without standard prefixes
              CHANGES="${CHANGES}- ${line}"
            fi
          done <<< "$COMMITS"
          
          # If no changes found, add a generic message
          if [[ -z "$CHANGES" ]]; then
            CHANGES="- General improvements and bug fixes"
          fi
          
          # Write changes to a file first
          echo "$CHANGES" > changes.txt
          
          # Create release notes file
          echo "# Release $NEW_VERSION ($BUMP_TYPE bump)" > release_notes.md
          echo "" >> release_notes.md
          echo "## Changes" >> release_notes.md
          cat changes.txt >> release_notes.md
          echo "" >> release_notes.md
          echo "For full changes, see the [commit history](https://github.com/${{ github.repository }}/commits/$NEW_VERSION)" >> release_notes.md
          
          # Create the release
          gh release create $NEW_VERSION \
            --title "Release $NEW_VERSION" \
            --notes-file release_notes.md
          echo "::endgroup::"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üîÑ Update major version tag
        run: |
          echo "::group::Updating major version tag"
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"
          MAJOR_VERSION=$(echo $NEW_VERSION | cut -d. -f1)
          
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          git tag -f $MAJOR_VERSION $NEW_VERSION
          git push -f https://${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git $MAJOR_VERSION
          
          echo "Updated major version tag: $MAJOR_VERSION -> $NEW_VERSION"
          echo "::endgroup::"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
