name: Tag and Release

on:
  push:
    branches:
      - main

jobs:
  tag-and-release:
    name: Tag and Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: üìä Determine version bump
        id: bump
        run: |
          echo "::group::Determining version bump type"
          # Get the latest commit message
          COMMIT_MSG=$(git log -1 --pretty=%B)
          
          # Determine bump type based on commit message
          if [[ "$COMMIT_MSG" == *"BREAKING CHANGE:"* ]] || [[ "$COMMIT_MSG" == *"MAJOR:"* ]]; then
            echo "BUMP_TYPE=major" >> $GITHUB_OUTPUT
          elif [[ "$COMMIT_MSG" == *"FEAT:"* ]] || [[ "$COMMIT_MSG" == *"FEATURE:"* ]] || [[ "$COMMIT_MSG" == *"MINOR:"* ]]; then
            echo "BUMP_TYPE=minor" >> $GITHUB_OUTPUT
          else
            echo "BUMP_TYPE=patch" >> $GITHUB_OUTPUT
          fi
          
          echo "Determined bump type: $(cat $GITHUB_OUTPUT | grep BUMP_TYPE | cut -d= -f2)"
          echo "::endgroup::"
      
      - name: üè∑Ô∏è Get latest tag
        id: latest_tag
        run: |
          echo "::group::Finding latest tag"
          # Get the latest tag or set to v0.0.0 if none exists
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"
          echo "::endgroup::"
      
      - name: üßÆ Calculate new version
        id: version
        run: |
          echo "::group::Calculating new version"
          LATEST_TAG="${{ steps.latest_tag.outputs.LATEST_TAG }}"
          BUMP_TYPE="${{ steps.bump.outputs.BUMP_TYPE }}"
          
          # Remove 'v' prefix for version calculation
          VERSION=${LATEST_TAG#v}
          
          # Split version into components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          
          # Increment version based on bump type
          if [ "$BUMP_TYPE" == "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$BUMP_TYPE" == "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi
          
          # Create new version string
          NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"
          echo "::endgroup::"
      
      - name: üìå Create and push tag
        run: |
          echo "::group::Creating and pushing tag"
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"
          BUMP_TYPE="${{ steps.bump.outputs.BUMP_TYPE }}"
          
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Create and push the new tag
          git tag -a $NEW_VERSION -m "Release $NEW_VERSION ($BUMP_TYPE bump)"
          git push https://${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git $NEW_VERSION
          
          echo "Created and pushed tag: $NEW_VERSION"
          echo "::endgroup::"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üìù Create GitHub Release
        run: |
          echo "::group::Creating GitHub Release"
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"
          BUMP_TYPE="${{ steps.bump.outputs.BUMP_TYPE }}"
          
          # Get all commits since the last tag
          LATEST_TAG="${{ steps.latest_tag.outputs.LATEST_TAG }}"
          COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s%n%b%n---")
          
          # Extract conventional commits and their details
          CHANGES=""
          CURRENT_COMMIT=""
          COMMIT_DETAILS=""
          READING_DETAILS=false
          
          while IFS= read -r line; do
            if [[ "$line" == "---" ]]; then
              # End of a commit
              if [[ "${CURRENT_COMMIT,,}" =~ ^(breaking change:|major:|feat:|feature:|minor:|fix:|patch:|chore:|docs:|style:|refactor:|perf:|test:|build:|ci:) ]]; then
                # Extract commit type and standardize it
                COMMIT_TYPE=$(echo "$CURRENT_COMMIT" | grep -io "^[a-zA-Z ]*:" | tr '[:lower:]' '[:upper:]')
                COMMIT_MSG=$(echo "$CURRENT_COMMIT" | sed -E "s/^[a-zA-Z ]*://i" | sed -e 's/^[[:space:]]*//')
                
                # Format the commit message
                FORMATTED_COMMIT="**${COMMIT_TYPE}** ${COMMIT_MSG}"
                
                if [[ -n "$COMMIT_DETAILS" ]]; then
                  CHANGES+="### ${FORMATTED_COMMIT}\n${COMMIT_DETAILS}\n\n"
                else
                  CHANGES+="- ${FORMATTED_COMMIT}\n"
                fi
              fi
              CURRENT_COMMIT=""
              COMMIT_DETAILS=""
              READING_DETAILS=false
            elif [[ -z "$CURRENT_COMMIT" ]]; then
              # First line of commit is the title
              CURRENT_COMMIT="$line"
              READING_DETAILS=true
            elif [[ "$READING_DETAILS" == true && -n "$line" ]]; then
              # Subsequent non-empty lines are details
              if [[ -n "$COMMIT_DETAILS" ]]; then
                COMMIT_DETAILS+="  $line\n"
              else
                COMMIT_DETAILS="  $line\n"
              fi
            fi
          done <<< "$COMMITS"
          
          # If no conventional commits found, use the PR title
          if [[ -z "$CHANGES" ]]; then
            COMMIT_MSG=$(git log -1 --pretty=%B)
            if [[ "$COMMIT_MSG" == *"Merge pull request"* ]]; then
              # Extract the PR title from merge message (after the PR number line)
              CLEAN_MSG=$(echo "$COMMIT_MSG" | grep -v "Merge pull request" | grep -v "^$" | head -n 1)
              
              # Check if PR title follows convention
              if [[ "${CLEAN_MSG,,}" =~ ^(breaking change:|major:|feat:|feature:|minor:|fix:|patch:|chore:|docs:|style:|refactor:|perf:|test:|build:|ci:) ]]; then
                # Extract commit type and standardize it
                COMMIT_TYPE=$(echo "$CLEAN_MSG" | grep -io "^[a-zA-Z ]*:" | tr '[:lower:]' '[:upper:]')
                COMMIT_MSG=$(echo "$CLEAN_MSG" | sed -E "s/^[a-zA-Z ]*://i" | sed -e 's/^[[:space:]]*//')
                CHANGES="- **${COMMIT_TYPE}** ${COMMIT_MSG}\n"
              else
                CHANGES="- ${CLEAN_MSG}\n"
              fi
            else
              CHANGES="- ${COMMIT_MSG}\n"
            fi
          fi
          
          # Create release notes with commit message conventions
          RELEASE_NOTES="Release $NEW_VERSION of Dioxus Build Action ($BUMP_TYPE bump)
          
          ## What's Changed
          ${CHANGES}
          ## Commit Message Conventions
          - \`BREAKING CHANGE:\` or \`MAJOR:\` - Major version bump (x.0.0)
          - \`FEAT:\`, \`FEATURE:\`, or \`MINOR:\` - Minor version bump (0.x.0)
          - Any other prefix - Patch version bump (0.0.x)
          
          For full changes, see the [commit history](https://github.com/${{ github.repository }}/commits/$NEW_VERSION)"
          
          gh release create $NEW_VERSION \
            --title "Release $NEW_VERSION" \
            --notes "$RELEASE_NOTES"
          echo "::endgroup::"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üîÑ Update major version tag
        run: |
          echo "::group::Updating major version tag"
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"
          MAJOR_VERSION=$(echo $NEW_VERSION | cut -d. -f1)
          
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          git tag -f $MAJOR_VERSION $NEW_VERSION
          git push -f https://${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git $MAJOR_VERSION
          
          echo "Updated major version tag: $MAJOR_VERSION -> $NEW_VERSION"
          echo "::endgroup::"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
